import autogen
import os
from common.database.cosmos.db_operations import fetch_top_k_candidates_by_count, fetch_top_k_candidates_by_percentage, update_application_status, execute_sql_query
from services.chatbot.functions import send_email
from ..prompts.multiagent_assistant_prompts import  executor_agent_system_message, fetcher_agent_system_message, email_agent_system_message, job_desc_creator_system_message, sql_query_generator_system_message, initiate_chat_system_message
from dotenv import load_dotenv


# Load environment variables from .env file in the project directory
import logging
import os
from pathlib import Path

# Try to find and load the .env file
env_paths = [
    ".env",  # Current directory
    "../.env",  # Parent directory
    "../../.env",  # Grandparent directory
    Path(os.path.dirname(os.path.abspath(__file__))).parent.parent / ".env",  # Absolute path to neunet_ai_services/.env
]

env_loaded = False
for env_path in env_paths:
    if os.path.exists(env_path):
        logging.info(f"Loading environment variables from {os.path.abspath(env_path)}")
        load_dotenv(dotenv_path=env_path)
        env_loaded = True
        break

if not env_loaded:
    logging.warning("Could not find .env file in any of the expected locations")
    
# Log environment variable status (without revealing actual values)
logging.info(f"AZURE_OPENAI_API_KEY present: {bool(os.getenv('AZURE_OPENAI_API_KEY'))}")
logging.info(f"AZURE_OPENAI_ENDPOINT present: {bool(os.getenv('AZURE_OPENAI_ENDPOINT'))}")
logging.info(f"deployment_name present: {bool(os.getenv('deployment_name'))}")
logging.info(f"api_type present: {bool(os.getenv('api_type'))}")
logging.info(f"api_version present: {bool(os.getenv('api_version'))}")



# Configuration for Azure OpenAI models
try:
    config_list = [{"model": os.getenv("deployment_name"),  
                  "api_key": os.getenv("AZURE_OPENAI_API_KEY"),
                  "base_url": os.getenv("AZURE_OPENAI_ENDPOINT"),
                  "api_type": os.getenv("api_type"),  
                  "api_version": os.getenv("api_version")}]
    
    # Validate config values
    for key, value in config_list[0].items():
        if not value:
            logging.warning(f"Missing configuration value for {key}")
            
except Exception as e:
    logging.error(f"Error setting up OpenAI configuration: {str(e)}")
    config_list = []

# Define agents only if configuration is valid
# Define global variables for agents
user_proxy = None
executor_agent = None
fetcher_agent = None
email_agent = None
job_desc_creator_agent = None
sql_query_generator_agent = None

def initialize_agents():
    """Initialize autogen agents if configuration is valid"""
    global user_proxy, executor_agent, fetcher_agent, email_agent, job_desc_creator_agent, sql_query_generator_agent
    
    try:
        if not config_list:
            logging.error("Cannot initialize agents: config_list is empty")
            return False
    except Exception as e:
        logging.error(f"Error checking config_list: {str(e)}")
        return False
            
        # Define the User Proxy Agent
        user_proxy = autogen.UserProxyAgent(
            name="user_proxy",
            human_input_mode="ALWAYS",
            max_consecutive_auto_reply=50,
            is_termination_msg=lambda x: x.get("content", "").rstrip().endswith("TERMINATE"),
            code_execution_config={"use_docker": False}
        )
        
        # Define the Executor Agent to run functions
        try:
            executor_agent = autogen.AssistantAgent(
                name="function_executor_agent",
                system_message=executor_agent_system_message,
                llm_config={
                    "config_list": config_list,
                    "functions": [
            {
                "name": "fetch_top_k_candidates_by_percentage",
                "description": "Fetches the top percentage of candidates (email and ranking only) for a given job ID. ",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "job_id": {
                            "type": "number",
                            "description": "The job ID for which to fetch the application data."
                        },
                        "percentage": {
                            "type": "number",
                            "description": "The percentage of top candidates to fetch, defaults to 10%."
                        }
                    },
                    "required": ["job_id"]
                }
            },
            {
                "name": "fetch_top_k_candidates_by_count",
                "description": "Fetches the top count of candidates (email and ranking only) for a given job ID.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "job_id": {
                            "type": "number",
                            "description": "The job ID for which to fetch the application data."
                        },
                        "percentage": {
                            "type": "number",
                            "description": "The count of top candidates to fetch, defaults to 10."
                        }
                    },
                    "required": ["job_id"]
                }
            },
            {
                "name": "send_email",
                "description": "Sends an email to a list of recipients.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "to_addresses": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            },
                            "description": "List of email addresses to send the email to."
                        },
                        "subject": {
                            "type": "string",
                            "description": "The subject of the email."
                        },
                        "body_plain": {
                            "type": "string",
                            "description": "The plain text content of the email."
                        }
                    },
                    "required": ["to_addresses", "subject", "body_plain"]
                }
            },
            {
                "name": "update_application_status",
                "description": "Updates the status of application for given job application and candidate email id.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "job_id": {
                            "type": "number",
                            "description": "The job ID for which to update the application status."
                        },
                        "candidate_email": {
                            "type": "string",
                            "description": "The email of the candidate whose status is to be updated."
                        },
                        "new_status": {
                            "type": "string",
                            "description": "The new status to be set for the candidate."
                        }
                    },
                    "required": ["job_id", "candidate_email", "new_status"]
                }
            },
            {
                "name": "execute_sql_query",
                "description": "Executes the given SQL query generated by the sql_query_generator_agent. This function can be used if there is no other function that solved user request.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "The SQL query to execute."
                        }
                    }
                }
            }

        ]
    },
)

# Register the functions with the executor agent
executor_agent.register_function(
    function_map={
        "fetch_top_k_candidates_by_percentage": fetch_top_k_candidates_by_percentage,
        "fetch_top_k_candidates_by_count": fetch_top_k_candidates_by_count,
        "send_email": send_email,
        "update_application_status": update_application_status,
        "execute_sql_query": execute_sql_query
    }
)

# Define the Fetcher Agent to retrieve data
fetcher_agent = autogen.AssistantAgent(
    name="data_fetcher_agent",
    system_message=fetcher_agent_system_message,
    llm_config={"config_list": config_list}
)

# Define the Email Agent for email operations
email_agent = autogen.AssistantAgent(
    name="email_agent",
    system_message=email_agent_system_message,
    llm_config={"config_list": config_list}
)

# Define the Job Description Creator Agent
job_desc_creator_agent = autogen.AssistantAgent(
    name="job_desc_creator_agent",
    system_message=job_desc_creator_system_message,
    llm_config={"config_list": config_list}
)

# Define the SQL Query Generator Agent
sql_query_generator_agent = autogen.AssistantAgent(
    name="sql_query_generator_agent",
    system_message=sql_query_generator_system_message,
    llm_config={"config_list": config_list}
)
        
        return True
        
    except Exception as e:
        logging.error(f"Error initializing agents: {str(e)}")
        logging.error(traceback.format_exc())
        return False

# Define the Group Chat with the agents
groupchat = autogen.GroupChat(
    agents=[user_proxy, fetcher_agent, job_desc_creator_agent, email_agent, executor_agent, sql_query_generator_agent],
    messages=[],
    max_round=50,
)
manager = autogen.GroupChatManager(groupchat=groupchat, llm_config={
    "config_list": config_list,
})

# Initiate the conversation with the User Proxy
def initiate_chat():
    user_proxy.initiate_chat(manager, message=initiate_chat_system_message)


# Initialize agents on module load
try:
    agents_initialized = initialize_agents()
    if not agents_initialized:
        logging.warning("Failed to initialize agents")
except Exception as e:
    logging.error(f"Error during agent initialization: {str(e)}")
    logging.error(traceback.format_exc())
    agents_initialized = False

def chat_step(user_message: str, chat_history=None, candidate_id=None):
    """Process a single user message and return a JSON-formatted response.
    
    Args:
        user_message: The message from the user
        chat_history: Optional chat history
        candidate_id: Optional candidate context ID
        
    Returns:
        JSON string containing the response with type and content fields
    """
    import json
    import logging
    import traceback
    from datetime import datetime, timedelta
    
    # Check if agents were properly initialized
    if not globals().get('agents_initialized', False):
        logging.error("Cannot process message: agents were not properly initialized")
        return json.dumps({"type": "text", "content": "The AI system is currently being updated. Please try again later."})
    
    # Check if required environment variables are set
    if not all([os.getenv("AZURE_OPENAI_API_KEY"), os.getenv("AZURE_OPENAI_ENDPOINT"), os.getenv("deployment_name")]):
        logging.error("Missing required environment variables for OpenAI API")
        return json.dumps({"type": "text", "content": "The AI system is not properly configured. Please contact the administrator."})
    
    try:
        from common.database.cosmos.db_operations import execute_sql_query
    except ImportError as e:
        logging.error(f"Failed to import database operations: {str(e)}")
        return json.dumps({"type": "text", "content": "The database connection is not properly configured. Please contact the administrator."})
    
    if chat_history is None:
        chat_history = []
    
    logging.info(f"[CHAT] Processing user message: '{user_message}'")
    if candidate_id:
        logging.info(f"[CHAT] With candidate context: candidate_id={candidate_id}")
    
    try:
        # Handle specific commands
        if "show job info" in user_message.lower() or "information about this job" in user_message.lower():
            # In a real implementation, we would fetch job details from the database
            job_info = {
                "title": "Senior Software Engineer",
                "company": "Innovative Tech Solutions",
                "location": "San Francisco, CA (Remote)",
                "description": "We're looking for a senior software engineer to join our team working on cutting-edge AI applications.",
                "requirements": "5+ years experience with Python, experience with machine learning frameworks, strong problem-solving skills.",
                "salary": "$150,000 - $180,000"
            }
            result = f"Here is information about the job:\n\nTitle: {job_info['title']}\nCompany: {job_info['company']}\nLocation: {job_info['location']}\nSalary: {job_info['salary']}\n\nDescription:\n{job_info['description']}\n\nRequirements:\n{job_info['requirements']}"
        
        elif "show top candidates" in user_message.lower() or "top candidates" in user_message.lower():
            # In a real implementation, we would call fetch_top_k_candidates_by_percentage or fetch_top_k_candidates_by_count
            try:
                # Try to fetch candidates from database (placeholder for now)
                # In production, this would use execute_sql_query to get real data
                candidates = [
                    {
                        "id": "c1", 
                        "name": "John Doe", 
                        "title": "Senior Developer", 
                        "matchScore": "95%",
                        "resume": {
                            "contact": {
                                "linkedin": "https://linkedin.com/in/johndoe",
                                "github": "https://github.com/johndoe"
                            }
                        }
                    },
                    {
                        "id": "c2", 
                        "name": "Jane Smith", 
                        "title": "Full Stack Engineer", 
                        "matchScore": "92%",
                        "resume": {
                            "contact": {
                                "linkedin": "https://linkedin.com/in/janesmith"
                            }
                        }
                    },
                    {
                        "id": "c3", 
                        "name": "Alex Johnson", 
                        "title": "Frontend Developer", 
                        "matchScore": "88%",
                        "resume": {
                            "contact": {
                                "github": "https://github.com/alexj"
                            }
                        }
                    }
                ]
                logging.info(f"[CHAT] Returning {len(candidates)} top candidates")
                return json.dumps({"type": "topCandidates", "candidates": candidates})
            except Exception as db_error:
                logging.error(f"[CHAT] Database error fetching candidates: {str(db_error)}")
                logging.error(traceback.format_exc())
                result = "Sorry, I couldn't retrieve the top candidates at this moment. Please try again later."
        
        elif "show jobs" in user_message.lower() or "jobs this candidate" in user_message.lower() or "jobs applied" in user_message.lower() or "applications" in user_message.lower():
            # Use candidate_id if available
            if candidate_id:
                logging.info(f"[CHAT] Fetching jobs for specific candidate: {candidate_id}")
                try:
                    # In a real implementation, we would fetch this candidate's specific jobs from the database
                    # using the candidate_id to filter the results
                    # For now, using realistic placeholder data with candidate-specific information
                    
                    # Try to get candidate name from database (placeholder for now)
                    candidate_name = "Alex Chen"  # This would come from database in real implementation
                    
                    now = datetime.now()
                    jobs = [
                        {"id": "j1", "title": "Senior Developer", "company": "Tech Corp", "appliedAt": (now - timedelta(days=14)).isoformat(), "status": "Interview Scheduled"},
                        {"id": "j2", "title": "Full Stack Engineer", "company": "Startup Inc", "appliedAt": (now - timedelta(days=30)).isoformat(), "status": "Application Received"},
                        {"id": "j3", "title": "Frontend Lead", "company": "Web Solutions", "appliedAt": (now - timedelta(days=45)).isoformat(), "status": "Under Review"}
                    ]
                    logging.info(f"[CHAT] Found {len(jobs)} jobs for candidate {candidate_id} ({candidate_name})")
                    
                    # Add a personalized message about the candidate's applications
                    message = f"Here are the jobs that {candidate_name} has applied for:"
                    
                    return json.dumps({
                        "type": "jobs_applied_cards", 
                        "jobs": jobs, 
                        "candidateId": candidate_id,
                        "message": message
                    })
                except Exception as db_error:
                    logging.error(f"[CHAT] Database error fetching jobs for candidate {candidate_id}: {str(db_error)}")
                    logging.error(traceback.format_exc())
                    result = f"Sorry, I couldn't retrieve the jobs for this candidate at this moment. Please try again later."
            else:
                logging.info("[CHAT] No candidate context available for jobs query")
                result = "To show jobs applied by a candidate, please view this chat from a candidate's profile page."
        
        elif "help" in user_message.lower():
            result = "I can help you with various tasks:\n\n- Show job information\n- Display top candidates for a job\n- Show jobs a candidate has applied to\n- Answer questions about the platform\n\nJust ask me what you need!"
        
        elif "summarize candidate" in user_message.lower() or "candidate summary" in user_message.lower() or "profile summary" in user_message.lower():
            # Provide a summary of the candidate if candidate_id is available
            if candidate_id:
                try:
                    # In a real implementation, we would fetch candidate details from the database
                    # For now, using placeholder data
                    candidate_name = "Alex Chen"  # This would come from database in real implementation
                    candidate_summary = {
                        "name": candidate_name,
                        "title": "Senior Software Engineer",
                        "experience": "8 years",
                        "skills": ["Python", "React", "Node.js", "AWS", "Docker"],
                        "education": "MS in Computer Science, Stanford University",
                        "applications": 3,
                        "match_score": "92%"
                    }
                    
                    result = f"### Candidate Summary for {candidate_summary['name']}\n\n" \
                            f"**Current Title:** {candidate_summary['title']}\n" \
                            f"**Experience:** {candidate_summary['experience']}\n" \
                            f"**Education:** {candidate_summary['education']}\n" \
                            f"**Key Skills:** {', '.join(candidate_summary['skills'])}\n\n" \
                            f"**Job Match:** {candidate_summary['match_score']}\n" \
                            f"**Applications:** {candidate_summary['applications']} jobs\n\n" \
                            f"You can ask me to 'show jobs applied' to see which positions this candidate has applied for."
                except Exception as e:
                    logging.error(f"[CHAT] Error generating candidate summary: {str(e)}")
                    logging.error(traceback.format_exc())
                    result = f"Sorry, I couldn't generate a summary for this candidate at this moment. Please try again later."
            else:
                result = "To summarize a candidate, please view this chat from a candidate's profile page."
                
        else:
            # Default response for other queries
            if candidate_id:
                try:
                    # Try to get candidate name from database (placeholder for now)
                    candidate_name = "Alex Chen"  # This would come from database in real implementation
                    
                    result = f"I'm here to help you evaluate {candidate_name}. You can ask me to:\n\n" \
                             f"- Show jobs this candidate has applied for\n" \
                             f"- Summarize the candidate's profile\n" \
                             f"- Compare with other candidates\n" \
                             f"- Suggest interview questions based on their background"
                except Exception as e:
                    logging.error(f"[CHAT] Error generating default candidate response: {str(e)}")
                    result = f"I understand you're asking about this candidate. What specific information would you like to know? You can ask to see their applied jobs, or ask for a summary of their profile."
            else:
                result = f"I'm here to help with your recruiting needs. You can ask me to show top candidates, job information, or other questions about the platform."
        
        # Append to chat history
        chat_history.append({"role": "user", "content": user_message})
        chat_history.append({"role": "assistant", "content": result})
        
        # Format the response as JSON for the frontend
        # If we haven't already returned a specialized response
        if isinstance(result, str):
            return json.dumps({"type": "text", "content": result})
        return result
        
    except Exception as e:
        logging.error(f"[CHAT] Error in chat_step: {str(e)}")
        logging.error(f"[CHAT] Error traceback: {traceback.format_exc()}")
        return json.dumps({"type": "text", "content": f"Sorry, I encountered an error processing your request. Please try again later."})



def start_new_chat(*args, **kwargs):
    """
    Placeholder for start_new_chat. Implement actual logic if needed.
    """
    logging.info("start_new_chat called (no-op)")
    return None


# Add a simple test function that can be called to verify the module is working
def test_module():
    """Test if the module is working properly"""
    import json
    try:
        # Check if environment variables are loaded
        env_vars = {
            "AZURE_OPENAI_API_KEY": bool(os.getenv("AZURE_OPENAI_API_KEY")),
            "AZURE_OPENAI_ENDPOINT": bool(os.getenv("AZURE_OPENAI_ENDPOINT")),
            "deployment_name": bool(os.getenv("deployment_name")),
            "api_type": bool(os.getenv("api_type")),
            "api_version": bool(os.getenv("api_version"))
        }
        
        # Check if agents are initialized
        agents = {
            "user_proxy": user_proxy is not None,
            "executor_agent": executor_agent is not None,
            "agents_initialized": globals().get('agents_initialized', False)
        }
        
        return json.dumps({
            "status": "ok",
            "environment_variables": env_vars,
            "agents": agents
        })
    except Exception as e:
        return json.dumps({
            "status": "error",
            "error": str(e)
        })



